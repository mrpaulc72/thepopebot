# Task File Templates

Standard formats for task files generated by the Project Orchestrator. Each platform has a tailored template optimized for how that platform is used.


## Universal Task File Header

Every task file, regardless of platform, starts with this YAML frontmatter:

```yaml
---
task_id: {PLATFORM}-{NNN}
task_name: {Descriptive Name}
platform: {claude-cowork | claude-code | cursor | warp | n8n | claude-chat}
phase: {1 | 2 | 3 | ...}
priority: {critical | high | medium | low}
estimated_effort: {small (< 30min) | medium (30min-2hr) | large (2hr+)}
status: {ready | blocked | in-progress | done}
depends_on: [{TASK-ID}, ...]
blocks: [{TASK-ID}, ...]
parallel_with: [{TASK-ID}, ...]
---
```


## Claude Cowork Task Template

```markdown
---
task_id: COWORK-{NNN}
task_name: {Name}
platform: claude-cowork
phase: {N}
priority: {level}
estimated_effort: {size}
status: ready
depends_on: []
blocks: []
parallel_with: []
---

# {Task Name}

## Objective
{One-paragraph description of what this task produces and why it matters to the project.}

## Context
{Background information needed to execute this task. Reference any files in /resources/ that provide additional context.}

## Prompt
> {The actual prompt to give to Claude in Cowork. Written in second person, ready to paste.
> This should be specific enough that Claude produces the right output without further clarification.
> Include tone, format, length, and any constraints.}

## Input Files
{List any files that should be in the Cowork folder before starting:}
- `resources/{filename}` — {description}
- `{other-task-output}` — {description}

## Expected Output
{Describe the file(s) this task should produce:}
- `{output-filename}.md` — {description of contents}

## Acceptance Criteria
- [ ] {Specific, verifiable criterion 1}
- [ ] {Specific, verifiable criterion 2}
- [ ] {Specific, verifiable criterion 3}

## Notes
{Any additional context, warnings, or tips for executing this task.}
```


## Claude Code Task Template

```markdown
---
task_id: CODE-{NNN}
task_name: {Name}
platform: claude-code
phase: {N}
priority: {level}
estimated_effort: {size}
status: ready
depends_on: []
blocks: []
parallel_with: []
---

# {Task Name}

## Objective
{One-paragraph description of the technical goal.}

## Technical Context
{Architecture decisions, tech stack, relevant patterns, existing codebase structure.}

## Prompt
> {The prompt to give Claude Code. Should be precise and technical.
> Include specific file paths, function signatures, or API contracts where relevant.
> Reference any specs or requirements documents.}

## Prerequisites
- [ ] {Required dependency, tool, or environment state}
- [ ] {Any prior task outputs needed}

## Implementation Spec
{Detailed technical requirements:}

### Files to Create/Modify
| File | Action | Description |
|------|--------|-------------|
| `{path}` | create/modify | {what it does} |

### Key Requirements
- {Technical requirement 1}
- {Technical requirement 2}

### API Contracts (if applicable)
```
{endpoint}: {method}
Request: {shape}
Response: {shape}
```

## Testing Requirements
- [ ] {Test case 1}
- [ ] {Test case 2}

## Acceptance Criteria
- [ ] {Specific, verifiable criterion 1}
- [ ] {Specific, verifiable criterion 2}
- [ ] All tests pass
- [ ] No linting errors
- [ ] Changes committed to branch `{branch-name}`

## Notes
{Architecture decisions, gotchas, performance considerations.}
```


## Cursor Task Template

```markdown
---
task_id: CURSOR-{NNN}
task_name: {Name}
platform: cursor
phase: {N}
priority: {level}
estimated_effort: {size}
status: ready
depends_on: []
blocks: []
parallel_with: []
---

# {Task Name}

## Objective
{One-paragraph description of the component or feature to build/modify.}

## Context
{Where this fits in the codebase. Reference existing patterns and components.}

## Prompt
> {Prompt optimized for Cursor's inline/composer workflow.
> Reference specific files by path. Describe the desired behavior.
> Include any design references or mockup descriptions.}

## Files to Work With
| File | Action | Why |
|------|--------|-----|
| `{path}` | modify | {reason} |
| `{path}` | create | {reason} |

## Design Reference
{Visual description, design tokens, or reference to mockups:}
- Layout: {description}
- Colors: {tokens or hex values}
- Typography: {font specs}
- Responsive behavior: {breakpoint rules}

## Component Spec
{If creating a component:}
- Props: `{prop definitions}`
- State: `{state management approach}`
- Events: `{user interactions to handle}`

## Acceptance Criteria
- [ ] {Visual criterion — what it looks like}
- [ ] {Behavioral criterion — what it does}
- [ ] {Responsive criterion — how it adapts}
- [ ] Matches existing code patterns in the project
- [ ] No TypeScript errors

## Notes
{Iteration guidance, known issues in existing code, browser compatibility.}
```


## Warp.dev Task Template

```markdown
---
task_id: WARP-{NNN}
task_name: {Name}
platform: warp
phase: {N}
priority: {level}
estimated_effort: {size}
status: ready
depends_on: []
blocks: []
parallel_with: []
---

# {Task Name}

## Objective
{One-paragraph description of the terminal/DevOps goal.}

## Context
{Environment details, server information, current state.}

## Commands / Workflow
{Step-by-step terminal workflow. Each step should be a discrete command or command sequence.}

### Step 1: {Description}
```bash
{command}
```
Expected output: {what success looks like}

### Step 2: {Description}
```bash
{command}
```
Expected output: {what success looks like}

## Environment Requirements
- OS: {target OS}
- Required tools: {list of CLI tools needed}
- Access: {SSH keys, credentials, permissions needed}
- Environment variables:
  - `{VAR_NAME}` — {description}

## Verification
```bash
{command to verify the task was completed successfully}
```
Expected: {what successful verification looks like}

## Rollback Plan
{If something goes wrong:}
```bash
{rollback commands}
```

## Acceptance Criteria
- [ ] {Verifiable system state 1}
- [ ] {Verifiable system state 2}

## Notes
{Security considerations, timing dependencies, maintenance implications.}
```


## n8n Task Template

```markdown
---
task_id: N8N-{NNN}
task_name: {Name}
platform: n8n
phase: {N}
priority: {level}
estimated_effort: {size}
status: ready
depends_on: []
blocks: []
parallel_with: []
---

# {Task Name}

## Objective
{One-paragraph description of what this automation does and why.}

## Workflow Overview
{High-level description of the automation flow:}
```
Trigger → Step 1 → Step 2 → ... → Output
```

## Trigger
- **Type**: {webhook | schedule | manual | event}
- **Configuration**: {cron expression, webhook path, or event source}

## Nodes

### Node 1: {Name}
- **Type**: {n8n node type, e.g., HTTP Request, Code, IF, Set}
- **Purpose**: {what this node does}
- **Configuration**:
  - {key setting 1}: {value}
  - {key setting 2}: {value}
- **Input**: {what data it receives}
- **Output**: {what data it passes forward}

### Node 2: {Name}
{Same structure as above}

## Connections / Services
| Service | Authentication | Required Scopes |
|---------|---------------|-----------------|
| {service name} | {OAuth / API Key / Basic} | {permissions needed} |

## Error Handling
- **On failure**: {retry / alert / fallback behavior}
- **Notification**: {who gets notified and how}

## Testing Plan
1. {Test scenario 1 — trigger condition + expected output}
2. {Test scenario 2 — error condition + expected behavior}

## Acceptance Criteria
- [ ] Workflow triggers correctly on {condition}
- [ ] Data flows through all nodes without errors
- [ ] Error handling works as specified
- [ ] {Business-specific success criterion}

## Notes
{Rate limits, API quotas, scheduling considerations, data privacy.}
```


## Orchestration Plan Template (00-orchestration-plan.md)

```markdown
---
project_name: {Project Name}
created: {YYYY-MM-DD}
total_tasks: {N}
platforms_used: [cowork, claude-code, cursor, warp, n8n]
estimated_total_effort: {hours or days}
---

# {Project Name} — Orchestration Plan

## Project Summary
{2-3 sentence description of the project, its goals, and the key deliverables.}

## Platform Distribution

| Platform | Tasks | Effort | Focus Area |
|----------|-------|--------|------------|
| Claude Cowork | {N} | {time} | {what} |
| Claude Code | {N} | {time} | {what} |
| Cursor | {N} | {time} | {what} |
| Warp.dev | {N} | {time} | {what} |
| n8n | {N} | {time} | {what} |

## Execution Phases

### Phase 1: {Phase Name} (Parallel)
{Description of what this phase accomplishes.}

| Task ID | Task Name | Platform | Effort | Status |
|---------|-----------|----------|--------|--------|
| {ID} | {Name} | {platform} | {effort} | ready |

### Phase 2: {Phase Name} (After Phase 1)
{Description.}

| Task ID | Task Name | Platform | Effort | Depends On | Status |
|---------|-----------|----------|--------|------------|--------|
| {ID} | {Name} | {platform} | {effort} | {deps} | blocked |

{Repeat for all phases}

## Dependency Graph
```
Phase 1 (parallel):
  COWORK-001 ──┐
  CODE-001 ────┤──→ Phase 2
  COWORK-002 ──┘
                    CURSOR-001 ──┐
                    N8N-001 ─────┤──→ Phase 3
                    COWORK-003 ──┘
```

## Critical Path
{Identify the longest dependency chain — the sequence that determines minimum project duration.}

1. {TASK-ID}: {Name} ({effort})
2. → {TASK-ID}: {Name} ({effort})
3. → {TASK-ID}: {Name} ({effort})
**Critical path duration: {total}**

## Clarifications Needed
{List any ambiguities or missing information that could affect execution.}

| Item | Affects | Default if Unresolved |
|------|---------|----------------------|
| {question} | {task IDs} | {suggested default} |

## Quick Start
To begin execution:
1. Review this plan and the resource files in `/resources/`
2. Start all Phase 1 tasks (they have no dependencies)
3. As each task completes, check which Phase 2+ tasks are unblocked
4. Update task status in each file as you progress
```


---
*Task Templates Reference v1.0 — February 2026*
*Customize templates as your workflow evolves*
